\subsubsection{NodeJS y ZMQ}

Durante el primer mes me dediqué a recordar NodeJS y ZMQ. Utilicé ambas durante la beca
que realicé el año pasado, la cuál también era en sistemas distribuidos. Para recordar
NodeJS utilicé el mismo libro que el año pasado \cite{therightway}.
El libro tiene una serie de capitulos con ejercicios básicos que explican progresivamente
todo lo necesario. ZeroMQ (ØMQ) \cite{zmq} es una libreria universal de código abierto de
comunicación mediante mensajes disponible en múltiples mensajes, entre ellos, Node. Es
la capa intermedia entre nuestro protocolo y el nivel de transporte. ZMQ se encarga de
todo lo necesario a nivel socket: envío y recepción de mensajes, creación y escucha de
sockets, serialización, conexión, restablecimiento de la misma... Hace que resulte muy
cómoda la implementación de la parte de comunicación entre nodos. Es una librería muy
reconocida y utilizada, además de que posee una amplia documentación.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{zmq.jpg}
	\caption{Node.js y ZMQ}
\end{figure}

\subsubsection{Comprensión EpTO}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\includegraphics[width=0.40\textwidth]{properties.png}
	\caption{Propiedades EpTO}
\end{wrapfigure}


Llegamos a la clave del proyecto, el algoritmo. Después de recordar Node y ZMQ, dediqué las proximas
semanas a estudiar el algoritmo, sirviéndome del artículo en el que había sido propuesto \cite{epto}.
En éste, se explica breve y claramente cada uno de los componentes del protocolo, cómo se demuestra
su correcto funcionamiento, y cómo se garanizan las cuatro propiedades propuestas: integridad, validez,
orden total y entrega probabilística. 

\paragraph{La idea}
La idea detrás de EpTO para la entrega probabilística es el problema de los hoyos y las canicas.
Los nodos son pensados como un conjunto de hoyos y cada mensaje como un conjunto de canicas. Los hoyos
a los que no caen canicas representan los nodos a los que sel mensaje no ha llegado debido a un
fallo. El objetivo es enviar el número de canicas por mensaje necesario para garantizar que la probabilidad de
que todos los hoyos hayan recibido el mensaje por lo menos una vez sea muy alta.

El protocolo consta de dos componentes principales: el componente de difusión y el componente de ordenación.


\paragraph{Componente de difusión}
\begin{wrapfigure}{r}{0.50\textwidth}
	\centering
	\includegraphics[width=0.50\textwidth]{disseminationcomponent.png}
	\caption{Componente de difusión}
\end{wrapfigure}
Este componente se encarga de la comunicación y difusión de mensajes, los cuales se denominan eventos.
Cada evento es un mensaje que se desea enviar a todos los nodos. El componente empaqueta múltiples eventos
en lo que llama BALL (lo que antes hemos entendido como canica), y la envía al resto de nodos. Antes de
comprender el funcionamiento completo necesitamos entender las variables utilizadas. Tenemos el conjunto de
todos los procesos correctos (view), K es el tamaño de la muestra de procesos a los que va a ser enviada
la próxima BALL, TTL (Time To Live) es el número máximo de saltos que un evento puede realizar (mismo
funcionamiento que los paquetes TCP-IP), delta es la duración de cada ronda, y nextBall es la proxima BALL
o conjunto de eventos próxima a enviar.

El funcionamiento es simple: cuando el proceso recibe un evento
nuevo desde la aplicación, lo añade a la próxima BALL. Cuando se recibe una BALL de otro proceso,
se analizan todos sus eventos de forma que si su TTL ya es muy alto se ignoran, y si no se actualizan
o/e introducen en la próxima BALL para ser reenviados. Cuando comienza la próxima ronda, se aumenta en
1 el TTL de todos los eventos pertenecientes a la próxima BALL, se selecciona un subconjunto de tamaño
K de todos los procesos correctos, y se les envía la BALL. Una vez hecho, se pasa la BALL al componente
de ordenación y se reinicia la BALL a conjunto vacío para la próxima ronda.

\clearpage

\paragraph{Componente de ordenación}
\begin{wrapfigure}{r}{0.60\textwidth}
	\centering
	\includegraphics[width=0.60\textwidth]{orderingcomponent.png}
	\caption{Componente de ordenación}
\end{wrapfigure}

Una vez que los eventos llegan al componente de ordenación se preparan y ordenan para entregarlos
cuando sea posible a la aplicación en orden total. Tenemos tres sencillas variables: recieved es el mapa de
eventos recibidos pero no entregados, delivered es el conjunto de eventos ya entregados y lastDeliveredTs
es el tiempo en el que se creo el último evento entregado. Dicho esto, el funcionamiento es el siguiente:
Para empezar, todos los eventos recibidos aumentan el TTL en 1, dado que acaba de terminar la ronda. Después,
para cada evento de la BALL, si no ha sido entregado ya y es posterior al último evento entregado,
se actualiza y/e introduce en el mapa de recibidos.

Después se añade a una lista los eventos que son
entregables por el momento (cuyo TTL es superior al límite), y se calcula el mínimo tiempo de creación
de los eventos que NO lo son. A estos primeros entregables restaremos aquellos cuyo tiempo de creación sea
posterior al mínimo de los que no son entregables, puesto que si un evento anterior a ellos no es entregable,
éstos tampoco lo son. Finalmente, ya tenemos los eventos que son realmente entregables a la aplicación,
así que se ordenan por proceso de origen y tiempo de creación y se entregan.

\paragraph{Reloj y sincronización}
La ordenación de los eventos o mensajes de éste algoritmo depende en gran medida del tiempo en el que
se generan. Para ello el artículo asume que utilizando un reloj global el orden se garantiza siempre,
aunque también dice que también puede funcionar con un reloj lógico perfectamente, y explica cómo.

\clearpage